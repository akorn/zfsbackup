#!/bin/zsh
#
# usage: zfsbackup-client [ --server server1[,server2[,...]] ] [ source1 [ source2 [ ... ] ] ]

SOURCES=/etc/zfsbackup/sources.d
DEFAULT_LOGFORMAT="%B %U:%G %M %l %o %i %C	%f%L"
[[ -x /usr/bin/chpst ]] && lockprog="chpst"

# An array we'll put the names of the servers we're asked to back up to in.
typeset -a backupservers BACKUPSERVERS

# we source the config once here, to seed the backupservers array
[[ -r /etc/zfsbackup/client.conf ]] && . /etc/zfsbackup/client.conf

# copy config variable into internal one; BACKUPSERVERS will be overridden by
# the config if we re-source it, which right now shouldn't be a problem, but
# it's better to be safe than sorry.
backupservers=($BACKUPSERVERS[@])
[[ -z $backupservers[@] ]] && backupservers=("")
final_exit_status=0

zmodload zsh/mapfile
zmodload zsh/datetime

# Run args with a lock held
function with_lock() {
	case "$lockprog" in
		chpst)
			chpst -L "/var/lock/zfsbackup-client.${zbSOURCENAME//\//_}.lock" $@;;
		"")
			$@;;
		*)
			echo "$0: WARNING: unsupported lockprog '$lockprog'. Continuing without locking." >&2
			$@;;
	esac
}

function get_sources() {	# TODO: perhaps the foreach loop over $backupservers should be in this function instead of the main program?
	if [[ -n "$1" ]]; then
		for i in "$@"; do
			if [[ -d "$i/." ]]; then	# direct path (absolute or relative), use it
				readlink -f "$i/."
			elif [[ -d "$SOURCES/$i/." ]]; then	# maybe it's the name of a sources.d directory, relative to $SOURCES?
				echo "$SOURCES/$i"
			elif [[ -z "$BACKUPSERVER" ]]; then # support the case when a generic source name like "var" was passed on the command line and there are several servers
				echo "$SOURCES/*/$i" # TODO: this is actually just a convention-based guess; we should really parse out the possible locations from the client.conf
			fi
		done
	else
		echo $SOURCES/*(/)
	fi
	return 0
}	

function start_logger() {
	# starts a logger coprocess if one doesn't exist already
	[[ -z "$have_logger" ]] && coproc logger --id -t "zfsbackup: $zbSOURCENAME"
	have_logger=1
}

# fetches source related metadata from current directory and exports it in environment variables
function update_metadata() {
	if [[ -z "$preclient_exit" ]]; then # running for first time
		export fsuuid=UNKNOWN; [[ -e fsuuid ]] && fsuuid=$(< fsuuid)
		fstype=$(findmnt -n -o FSTYPE ./path/.) || fstype=UNKNOWN
		export fstype
	else # pre-client already run; some of the above may have changed as a result
		if [[ -e fsuuid ]]; then
			fsuuid=$(< fsuuid)
			# the following elif branch doesn't make sense before running pre-client as the fs to be backed up may not even be mounted yet
		elif \
			   ! fsuuid=$(findmnt ./path/. -n -o UUID) \
			&& ! fsuuid=$(findmnt ./path/. -n -o SOURCE); then	# zfs path name
			fsuuid=$(readlink -f ./path/.)	# last resort, for example if we're only backing up a subdirectory
			# maybe instead of trying to shoehorn something useful into fsuuid, we should export all data returned by findmnt instead?
		fi
		fstype=$(findmnt -n -o FSTYPE ./path/.) || fstype=UNKNOWN
		if [[ $fstype = zfs ]]; then	# if zfs, see if we backed up a snapshot
			local source=$(findmnt -n -o SOURCE ./path/.)
			if [[ $source =~ .@. ]]; then	# there must be at least one character before and after the @ for it to be a valid zfs snapshot name
				export snapshot_name=$source
				export snapshot_created=$(zfs get -Hp -o value creation $source)
			else
				unset snapshot_name snapshot_created
			fi
		fi
	fi
}

if [[ "$1" == "--server" ]]; then
	shift
	backupservers=(${=1//,/ })
	shift
elif [[ -n "$1" ]]; then	# if we have were given the name(s) of sources.d directory/ies, the server is implicit, so don't iterate over servers defined in client.conf
	backupservers=("")
fi	# note: when given a mix of absolute and relative paths, the result is undefined

# the array contains at least one item (the empty string if nothing else)
for BACKUPSERVER in "$backupservers[@]"; do

	export BACKUPSERVER	# make this available to pre-client and post-client scripts
	# we have to source the config here so that $BACKUPSERVER
	# can be expanded in it where needed
	[[ -r /etc/zfsbackup/client.conf ]] && . /etc/zfsbackup/client.conf

	for zbSOURCENAME in $(get_sources "$@"); do # get_sources only returns absolute paths
		export zbSOURCENAME # make this available to pre-client and post-client scripts
		unset rsync_options
		unset USER
		unset preclient_exit preclientd_exit postclient_exit postclientd_exit
		unset rsync_exit
		echo "$0: INFO: processing $zbSOURCENAME." >&2
		cd "$zbSOURCENAME" || {
			echo "$0: WARNING: can't chdir to $zbSOURCENAME. Skipping." >&2
			continue
		}
		[[ -r url ]] || {
			echo "$0: ERROR: $zbSOURCENAME is missing url. Skipping." >&2
			continue
		}
		url="$(head -n 1 url)"
		[[ -r bwlimit ]] && rsync_options=($rsync_options --bwlimit="$(<bwlimit)")
		[[ -e compress ]] && rsync_options=($rsync_options -z)
		[[ -r compress-level ]] && rsync_options=($rsync_options --compress-level="$(<compress-level)")
		[[ -r exclude ]] && rsync_options=($rsync_options --exclude-from="$(pwd)/exclude")
		[[ -r files ]] && rsync_options=($rsync_options --files-from="$(pwd)/files")
		[[ -r filter ]] && rsync_options=($rsync_options $(sed 's/^/--filter /' <filter))
		[[ -r include ]] && rsync_options=($rsync_options --include-from="$(pwd)/include")
		[[ -r log-file-format ]] && LOGFORMAT="$(<log-file-format)" || LOGFORMAT="$DEFAULT_LOGFORMAT"
		{ [[ -e log-file ]] || [[ -L log-file ]] } && rsync_options=($rsync_options --log-file="$(readlink -f log-file)" --log-file-format="$LOGFORMAT")
		[[ -e no-acls ]] || rsync_options=($rsync_options -A)
		[[ -e no-delete ]] || rsync_options=($rsync_options --delete)
		[[ -e no-delete-excluded ]] || rsync_options=($rsync_options --delete-excluded)
		[[ -e no-hard-links ]] || rsync_options=($rsync_options -H)
		[[ -e no-inplace ]] || rsync_options=($rsync_options --inplace)
		[[ -e no-inplace ]] && ! [[ -e no-sparse ]] && rsync_options=($rsync_options -S)
		[[ -e no-partial ]] || rsync_options=($rsync_options --partial)
		[[ -e no-xattrs ]] || rsync_options=($rsync_options -X)
		[[ -e no-xdev ]] || rsync_options=($rsync_options -x)
		[[ -r options ]] && rsync_options=($rsync_options "${(f)mapfile[options]}")
		[[ -r password ]] && rsync_options=($rsync_options --password-file="$(pwd)/password")
		[[ -r timelimit ]] && timelimit=(timeout -k 5 "$(<timelimit)") || unset timelimit
		[[ -r timeout ]] && rsync_options=($rsync_options --timeout="$(<timeout)") \
			|| rsync_options=($rsync_options --timeout=3600)
		[[ -r username ]] && export LOGNAME=$(head -n 1 username)
		export rsync_options # make this available to pre-client and post-client scripts
		( # subshell so that we can redirect stdout/stderr safely, as well as use 'exit'
			export starttime=$EPOCHSECONDS

			update_metadata

			[[ -e stdout ]] && exec >stdout || { start_logger; exec >&p }
			[[ -e stderr ]] && exec 2>stderr || { start_logger; exec 2>&p }

# Lock usage is still slightly racy; for example, it's possible that pre-client will be run twice.
# To avoid that, the entire subshell bit would have to be in a separate script.
			if [[ -x check ]]; then
				with_lock ./check
				check_result="$?"
				echo $check_result >check-exit-status	# TODO: maybe output files like this one should go to a subdirectory?
				[[ "$check_result" = "0" ]] || {
					echo "$EPOCHSECONDS CHECKFAILED_$check_result $zbSOURCENAME"
					exit $check_result
				}
			fi

# Not reached if check_result != 0
			if [[ -x pre-client ]]; then
				with_lock ./pre-client
				preclient_exit="$?"
				echo $preclient_exit >pre-client-exit-status
			else
				preclient_exit="0"
			fi
			if [[ -d pre-client.d ]]; then
				with_lock run-parts --report ./pre-client.d
				preclientd_exit="$?"
				((preclient_exit+=preclientd_exit))
				echo $preclientd_exit >pre-client.d-exit-status
			else
				preclientd_exit="0"
			fi

			update_metadata
			if [[ -n "$snapshot_name" ]]; then
				echo "$snapshot_name" >last-backed-up-snapshot-name
				echo "$snapshot_created" >last-backed-up-snapshot-creation
				touch --date @$snapshot_created last-backed-up-snapshot-creation
			fi

			if [[ "$preclient_exit" = "0" ]] && [[ "$preclientd_exit" = "0" ]]; then
				[[ -f path ]] && mypath="$(head -n 1 path)"
				[[ -f path ]] || mypath=path/.
				if [[ -z "$mypath" ]]; then
# this is an internal error that I want to be sure is logged (and we shouldn't run rsync with an empty $mypath).
					echo "$0: FATAL: mypath variable was empty while processing $zbSOURCENAME." >&2
					rsync_exit=111
				else
					for kludge in {1..10}; do	# switching to auto-mounted zfs snapshots doesn't always work on the first try on some kernels
						cd "$mypath" && cdsuccess=1 && break
						sleep 0.5
					done
					if [[ "$cdsuccess" = "1" ]]; then
						with_lock $timelimit rsync -a $rsync_options[@] . "$url"
						rsync_exit="$?"
						echo $rsync_exit >"$zbSOURCENAME/rsync-exit-status"
						if [[ "$rsync_exit" = 0 ]]; then
							touch "$zbSOURCENAME/stamp-success"
							rm -f "$zbSOURCENAME/stamp-failure" 2>/dev/null
							if [[ -n "$snapshot_name" ]]; then
								echo "$snapshot_name" >last-successfully-backed-up-snapshot-name
								echo "$snapshot_created" >last-successfully-backed-up-snapshot-creation
								touch --date @$snapshot_created last-successfully-backed-up-snapshot-creation
							fi
						else
							# we don't remove stamp-success because it can be used to keep track of when the last successful backup took place
							echo "rsync returned $rsync_exit" >"$zbSOURCENAME/stamp-failure"
						fi
					else
						echo "$0: FATAL: unable to chdir to $mypath." >&2
						rsync_exit=111
					fi
				fi
			else
				: >"$zbSOURCENAME/stamp-failure"
				((preclient_exit)) && echo "pre-client returned $preclient_exit" >>"$zbSOURCENAME/stamp-failure"
				((preclientd_exit)) && echo "pre-client.d returned $preclient_exit" >>"$zbSOURCENAME/stamp-failure" 
			fi
			cd "$zbSOURCENAME"
			if [[ -x post-client ]]; then
				with_lock ./post-client "$preclient_exit" "$preclientd_exit" "$rsync_exit"
				postclient_exit=$?
				echo $postclient_exit >post-client-exit-status
			else
				postclient_exit=0
			fi
			if [[ -d post-client.d ]]; then
				with_lock run-parts --report --arg "$preclient_exit" "$preclientd_exit" "$rsync_exit" post-client.d
				postclientd_exit="$?"
				((postclient_exit+=postlientd_exit))
				echo $postclientd_exit >post-client.d-exit-status
			else
				postclientd_exit=0
			fi

# logging (will become inventory later)
			update_metadata
			echo -n "$EPOCHSECONDS "
			if [[ $preclient_exit = 0 ]]; then
				if [[ $rsync_exit = 0 ]]; then
					echo -n "RSYNC_SUCCESS "
				else
					echo -n "RSYNC_FAIL_$rsync_exit "
				fi
			else
				echo -n "PRECLIENT_FAIL_$preclient_exit "
			fi
			echo -n "$zbSOURCENAME "
			echo -n "$fsuuid "
			echo -n "$url "
			echo -n "$fstype "
			echo -n "$snapshot_name "
			echo -n "$snapshot_created "
			echo -n "$preclient_exit "
			echo -n "$postclient_exit "
			echo "$starttime"
			echo $[rsync_exit+postclient_exit+postclientd_exit] >zfsbackup-client-exit-status
			exit $[rsync_exit+postclient_exit+postclientd_exit]
		)
		((final_exit_status+=$?))
	done # for zbSOURCENAME in $(get_sources $*); do
done # for BACKUPSERVER in $backupservers[@]; do
exit $final_exit_status
